//! Event based parsing for Markdown blocks.
//!
//! Supports the CommonMark spec with GitHub extensions. This only implements
//! the block level parsing of the spec (i.e. no inlines).

use std::collections::VecDeque;
use std::fmt;

use regex::Regex;

use super::common;
use super::Span;

use super::table_parser::{parse_table_row, Row, TableRow};

pub fn parse_blocks<'a>(input: &'a str) -> BlockIterator<'a> {
	BlockIterator::new(input)
}

/// Events generated by the block parser.
///
/// The events generated by the parser are designed in such a way to allow the
/// construction of the Markdown document tree.
///
/// Note that the events do not correspond 1-to-1 with Markdown elements, since
/// that requires some further processing and state keeping (particularly for
/// lists).
#[derive(Clone)]
pub enum BlockEvent<'a> {
	/// Event generated at the opening of a container block.
	Start(Container),
	/// Event generated at the closing of a container block.
	End(Container),
	/// Event generated for a leaf block element.
	Leaf(Leaf<'a>),
}

impl<'a> fmt::Debug for BlockEvent<'a> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		match self {
			BlockEvent::Start(elem) => {
				write!(f, "<{}", elem.tag())?;
				elem.fmt_attrs(f)?;
				write!(f, ">")?;
				Ok(())
			}
			BlockEvent::End(elem) => write!(f, "</{}>", elem.tag()),
			BlockEvent::Leaf(elem) => write!(f, "{:?}", elem),
		}
	}
}

/// Information for a list.
#[derive(Clone)]
pub struct ListInfo {
	/// For ordered lists this contains the start index. This is `None` for
	/// unordered lists.
	pub ordered: Option<usize>,
	/// The character that was used to mark this list item.
	pub marker: char,
	/// Relative indentation of the content of this list item.
	pub text_indent: usize,
	/// Indentation of the list marker.
	pub base_indent: usize,
	/// Contains the task state if this is a task item.
	pub task: Option<bool>,
}

impl ListInfo {
	pub fn is_next_same_list(&self, next: &ListInfo) -> bool {
		if self.ordered.is_some() != next.ordered.is_some() {
			false
		} else if self.marker != next.marker {
			false
		} else if next.base_indent >= 2 {
			false
		} else {
			true
		}
	}
}

/// Container blocks.
#[derive(Clone)]
pub enum Container {
	/// Markdown blockquote block.
	BlockQuote,
	/// List item.
	ListItem(ListInfo),
}

enum CanContinue {
	No,
	Yes {
		length: usize,
		column: Option<usize>,
		indent: usize,
	},
}

impl Container {
	/// HTML tag name for this container.
	fn tag(&self) -> &'static str {
		match self {
			Container::BlockQuote => "blockquote",
			Container::ListItem(..) => "li",
		}
	}

	/// Output this container's tag attributes.
	fn fmt_attrs(&self, f: &mut fmt::Formatter) -> fmt::Result {
		match self {
			&Container::BlockQuote => Ok(()),
			&Container::ListItem(ListInfo {
				base_indent,
				ordered,
				task,
				..
			}) => {
				if base_indent > 0 {
					write!(f, " indent=\"{}\"", base_indent)?;
				}
				if let Some(index) = ordered {
					if index != 1 {
						write!(f, " start=\"{}\"", index)?;
					}
				}
				if let Some(task) = task {
					write!(f, " task=\"{}\"", task)?;
				}
				Ok(())
			}
		}
	}

	/// Check if the prefix of `line` allow for the continuation of this
	/// container, skipping any markings.
	///
	/// Returns `true` if the container is continued, the number of bytes
	/// to skip and an optional target column.
	fn can_continue(&self, line: &str, column: usize) -> CanContinue {
		match self {
			&Container::BlockQuote => {
				let (indent, bytes) = common::indent_width(line, column);
				if indent > 3 {
					CanContinue::No
				} else if line.starts_with("> ") {
					CanContinue::Yes {
						length: 2 + bytes,
						column: None,
						indent: 0,
					}
				} else if line.starts_with(">") {
					CanContinue::Yes {
						length: 1 + bytes,
						column: None,
						indent: 0,
					}
				} else {
					CanContinue::No
				}
			}
			&Container::ListItem(ListInfo {
				base_indent,
				text_indent,
				..
			}) => {
				if line.trim().len() == 0 {
					// List item can continue through empty lines
					CanContinue::Yes {
						length: 0,
						column: None,
						indent: 0,
					}
				} else {
					// We consider the list item continued if we can skip all
					// of its indentation.
					let target_indent = base_indent + text_indent;
					let mut line = line;
					let mut new_column = column;
					let mut skip = 0;
					loop {
						if let Some(ch) = line.chars().next() {
							if ch == ' ' || ch == '\t' {
								let col = common::col(ch, new_column);
								if col - column <= target_indent {
									new_column = col;
									line = &line[1..];
									skip += 1;
								} else {
									if ch == '\t' {
										// advance column without really
										// consuming the tab to simulate
										// partially consuming it
										new_column = column + target_indent;
									}
									break;
								}
							}
						}
					}

					if new_column - column == target_indent {
						CanContinue::Yes {
							length: skip,
							column: Some(new_column),
							indent: new_column - column,
						}
					} else {
						CanContinue::No
					}
				}
			}
		}
	}
}

/// Leaf blocks.
#[derive(Clone)]
pub enum Leaf<'a> {
	/// A single paragraph of markdown text.
	Paragraph { text: Span<'a> },
	/// HTML code block.
	HTML {
		/// Span of HTML code.
		code: Span<'a>,
		/// End condition for the HTML block. If `None` the end condition is
		/// the empty line.
		end: Option<&'static str>,
	},
	/// Link reference definition.
	LinkReference {
		/// Link target.
		url: &'a str,
		/// Link label, not including the `[]` delimiters.
		label: Span<'a>,
		/// Link title, not including the quotes.
		title: Span<'a>,
	},
	/// Indented code block.
	IndentedCode {
		/// Raw code span.
		code: Span<'a>,
	},
	/// Fenced code block.
	FencedCode {
		/// The fence delimiter.
		fence: &'a str,
		/// Raw code span, not including the delimiters or info string.
		code: Span<'a>,
		/// If the info string starts with a language tag, this will be it.
		lang: Option<&'a str>,
		/// Remaining info string, after extracting the language tag.
		info: Option<&'a str>,
	},
	/// Thematic break.
	Break,
	/// Setext or ATX header event.
	///
	/// - For a Setext header, this will be generated right after the
	///   respective [Paragraph].
	/// - For ATX headers this will contain the inline text for the header.
	Header {
		/// Header level from 1 to 6.
		level: u8,
		/// Header text.
		text: Span<'a>,
	},
	/// Table element.
	Table {
		span: Span<'a>,
		head: Option<TableRow<'a>>,
		body: Vec<TableRow<'a>>,
		cols: Option<usize>,
	},
}

impl<'a> fmt::Debug for Leaf<'a> {
	fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
		match self {
			Leaf::Paragraph { text } => write!(f, "<p>{}</p>", text),
			Leaf::HTML { code, .. } => write!(f, "<html>\n{}\n</html>", code),
			Leaf::LinkReference { url, label, title } => write!(f, "<a href={:?} title={:?}>{}</a>", url, title, label),
			Leaf::IndentedCode { code } => write!(f, "<code>\n{}\n</code>", code),
			Leaf::FencedCode { code, lang, info, .. } => {
				write!(f, "<code lang={:?} info={:?}>\n{}\n</code>", lang, info, code)
			}
			Leaf::Break => write!(f, "<hr/>"),
			Leaf::Header { level, text } => write!(f, "<h{0}>{1}</h{0}>", level, text),
			Leaf::Table { span, head, body, .. } => {
				write!(f, "<table>")?;
				if let Some(head) = head {
					write!(f, "\n  <tr>")?;
					for (th, align) in head.iter(span.clone()) {
						write!(f, "<th")?;
						align.fmt_attr(f)?;
						write!(f, ">{}</th>", th)?;
					}
					write!(f, "</tr>")?;
				}
				for row in body.iter() {
					write!(f, "\n  <tr>")?;
					for (td, align) in row.iter(span.clone()) {
						write!(f, "<td")?;
						align.fmt_attr(f)?;
						write!(f, ">{}</td>", td)?;
					}
					write!(f, "</tr>")?;
				}
				write!(f, "\n</table>")
			}
		}
	}
}

/// States used by [BlockIterator].
enum IteratorState {
	None,
	Open(usize, usize, Option<Container>),
	Text(usize, usize),
	Empty(usize, usize),
	End,
}

impl Default for IteratorState {
	fn default() -> Self {
		IteratorState::None
	}
}

enum LeafState<'a> {
	Closed(Leaf<'a>),
	ClosedAndConsumed(Leaf<'a>),
	Open(Leaf<'a>),
}

/// Iterates over [Event]s in a markdown text.
pub struct BlockIterator<'a> {
	state:  IteratorState,
	buffer: &'a str,
	offset: usize,
	column: usize,
	inline: Option<Leaf<'a>>,
	blocks: VecDeque<Container>,

	next_line: Option<(usize, usize)>,
}

impl<'a> BlockIterator<'a> {
	pub fn new(input: &'a str) -> BlockIterator<'a> {
		BlockIterator {
			state:  IteratorState::None,
			buffer: input,
			offset: 0,
			column: 0,
			inline: None,
			blocks: Default::default(),

			next_line: Default::default(),
		}
	}

	fn get_next(&mut self) -> Option<BlockEvent<'a>> {
		// Loop until a generating state is found. Returns the new state and
		// the next Event.
		let (state, next) = loop {
			// Match the current state and return the next state.
			self.state = match std::mem::take(&mut self.state) {
				// Final state after the input has been consumed.
				IteratorState::End => {
					break (IteratorState::End, None);
				}

				// This is the state at the start of the input or at the start
				// of a new line.
				IteratorState::None => {
					if self.at_end() {
						if let Some(inline) = std::mem::take(&mut self.inline) {
							let inline = self.close_leaf(inline);
							break (IteratorState::None, Some(BlockEvent::Leaf(inline)));
						} else if self.blocks.len() > 0 {
							let closed = self.blocks.pop_back().unwrap();
							break (IteratorState::None, Some(BlockEvent::End(closed)));
						} else {
							IteratorState::End
						}
					} else {
						// Skip any markers for currently open blocks...
						let (open_count, indent) = self.skip_opened();
						// and next check for blocks to open.
						IteratorState::Open(open_count, indent, None)
					}
				}

				// State at the beginning of a line, after skipping current
				// block markers, when checking for new blocks to open.
				IteratorState::Open(opened, indent, None) => {
					if let Some(elem) = self.parse_container_start() {
						IteratorState::Open(opened, indent, Some(elem))
					} else {
						IteratorState::Text(opened, indent)
					}
				}

				// State when a block open has been matched...
				IteratorState::Open(opened, indent, Some(elem)) => {
					if let Some(inline) = std::mem::take(&mut self.inline) {
						// ...first generate any pending inline (e.g. paragraph)
						let inline = self.close_leaf(inline);
						break (
							IteratorState::Open(opened, indent, Some(elem)),
							Some(BlockEvent::Leaf(inline)),
						);
					} else if self.blocks.len() > opened {
						// ...then close any non-continued open blocks
						let closed = self.blocks.pop_back().unwrap();
						break (
							IteratorState::Open(opened, indent, Some(elem)),
							Some(BlockEvent::End(closed)),
						);
					} else {
						// ...finally generate the new block and go back to the
						// empty open state to continue checking for new blocks.
						self.blocks.push_back(elem.clone());
						break (IteratorState::Open(opened, indent, None), Some(BlockEvent::Start(elem)));
					}
				}

				// State when a blank line is found.
				IteratorState::Empty(opened, indent) => {
					if self.blocks.len() > opened {
						// ...then close any non-continued open blocks
						let closed = self.blocks.pop_back().unwrap();
						break (IteratorState::Empty(opened, indent), Some(BlockEvent::End(closed)));
					} else {
						// ...finally just reset the state for the next line
						IteratorState::None
					}
				}

				// State when matching the text content of a line
				IteratorState::Text(opened, indent) => {
					let (offset, column) = (self.offset, self.column);

					// Find the end of the line.
					let (next_line, eol) = self.line_end();
					let cur_line = &self.buffer[self.offset..next_line];

					let mut do_skip = true;
					let (next_state, elem) = if let Some(inline) = std::mem::take(&mut self.inline) {
						// If there is a current leaf block open, append text
						// to it...
						match self.append_leaf(inline, offset, next_line - eol, column) {
							LeafState::Open(leaf) => {
								self.inline = Some(leaf);
								(IteratorState::None, None)
							}
							LeafState::ClosedAndConsumed(leaf) => {
								// ...if that closed the block, generate it.
								let leaf = self.close_leaf(leaf);
								(IteratorState::None, Some(BlockEvent::Leaf(leaf)))
							}
							LeafState::Closed(leaf) => {
								do_skip = false;
								let leaf = self.close_leaf(leaf);
								(IteratorState::None, Some(BlockEvent::Leaf(leaf)))
							}
						}
					} else if cur_line.trim().len() == 0 {
						// If the line is empty, handle it
						(IteratorState::Empty(opened, indent), None)
					} else {
						// Create a new span of text and parse it as a leaf
						// block.
						let span = Span {
							buffer:     self.buffer,
							column:     column,
							offset_sta: offset,
							offset_end: next_line - eol,
							indent:     indent,
							quotes:     self.cur_quotes(),
						};
						match self.parse_leaf(span) {
							LeafState::Open(leaf) => {
								self.inline = Some(leaf);
								(IteratorState::None, None)
							}
							LeafState::ClosedAndConsumed(leaf) => {
								let leaf = self.close_leaf(leaf);
								(IteratorState::None, Some(BlockEvent::Leaf(leaf)))
							}
							LeafState::Closed(_) => unreachable!(),
						}
					};

					if do_skip {
						self.offset = next_line;
						self.column = 0;
					}

					if let Some(elem) = elem {
						break (next_state, Some(elem));
					} else {
						next_state
					}
				}
			};
		};

		self.state = state;
		next
	}

	/// Skip the continuation markers for the currently open blocks.
	///
	/// Returns the number of blocks that can continue opened and the base
	/// indentation of the last open block.
	fn skip_opened(&mut self) -> (usize, usize) {
		let mut last_indent = 0;
		for i in 0..self.blocks.len() {
			let line = self.cur_line();
			if let CanContinue::Yes { length, column, indent } = self.blocks[i].can_continue(line, self.column) {
				last_indent = indent;
				if let Some(column) = column {
					self.offset += length;
					self.column = column;
				} else {
					self.skip(length);
				}
			} else {
				return (i, last_indent);
			}
		}
		(self.blocks.len(), last_indent)
	}

	/// Return the number of open blockquotes.
	fn cur_quotes(&self) -> usize {
		(self.blocks)
			.iter()
			.filter(|x| if let Container::BlockQuote = x { true } else { false })
			.count()
	}

	/// Parse opening block markers at the current position.
	fn parse_container_start(&mut self) -> Option<Container> {
		// Save current state in case we fail.
		let (offset, column) = (self.offset, self.column);

		// Parse next block.
		let result = {
			// Skip optional indentation before the element
			let start_col = self.column;
			let (indent, bytes) = common::indent_width(self.cur_line(), self.column);
			self.column += indent;
			self.offset += bytes;
			let base_indent = self.column - start_col;
			let base_column = self.column;
			if base_indent > 3 {
				// We can have at most 3 spaces before becoming an indented
				// code block.
				None
			} else if self.skip_if('>') {
				// ----------
				// Blockquote
				// ----------
				self.skip_if(' ');
				Some(Container::BlockQuote)
			} else if self.text().starts_with(|ch| ch == '-' || ch == '+' || ch == '*') {
				// -----------------------
				// List marker (unordered)
				// -----------------------

				let marker = self.next_char();
				self.skip_chars(1);
				let start_col = self.column;
				while self.text().starts_with(|ch| ch == ' ' || ch == '\t') {
					self.skip_chars(1);
				}
				let text_indent = self.column - start_col;

				if text_indent == 0 {
					// At least one space is needed after the list marker
					None
				} else {
					// The actual indent also considers the list item itself.
					let text_indent = self.column - base_column;
					let task = self.parse_list_task();
					let list_info = ListInfo {
						marker,
						text_indent,
						base_indent,
						task,

						ordered: None,
					};
					Some(Container::ListItem(list_info))
				}
			} else if self.text().starts_with(|ch: char| ch.is_ascii_digit()) {
				// ---------------------
				// List marker (ordered)
				// ---------------------

				// Note that the spec limits the list index to 9 digits to
				// prevent overflow in browsers.
				let mut index = self.next_char().to_digit(10).unwrap() as usize;
				self.skip_chars(1);
				for _ in 0..8 {
					if !self.at_end() {
						let next = self.next_char();
						if let Some(digit) = next.to_digit(10) {
							index = index * 10 + (digit as usize);
							self.skip_chars(1);
						} else {
							break;
						}
					}
				}
				if self.text().starts_with(|ch| ch == '.' || ch == ')') {
					// From here, the parsing is the same as for the unordered
					// case.
					let marker = self.next_char();
					self.skip_chars(1);

					let start_col = self.column;
					while self.text().starts_with(|ch| ch == ' ' || ch == '\t') {
						self.skip_chars(1);
					}
					let text_indent = self.column - start_col;

					if text_indent == 0 {
						None
					} else {
						let text_indent = self.column - base_column;
						let task = self.parse_list_task();
						let list_info = ListInfo {
							marker,
							text_indent,
							base_indent,
							task,
							ordered: Some(index),
						};
						Some(Container::ListItem(list_info))
					}
				} else {
					None
				}
			} else {
				None
			}
		};

		// Restore parser state if we failed to match.
		if result.is_none() {
			self.offset = offset;
			self.column = column;
		}
		result
	}

	fn parse_list_task(&mut self) -> Option<bool> {
		let result = if self.text().starts_with("[x]") || self.text().starts_with("[X]") {
			Some(true)
		} else if self.text().starts_with("[ ]") {
			Some(false)
		} else {
			None
		};
		let result = if let Some(checked) = result {
			let (offset, column) = (self.offset, self.column);
			self.skip_chars(3);
			if !self.skip_if(' ') && !self.skip_if('\t') {
				if self.cur_line().trim().len() > 0 {
					self.offset = offset;
					self.column = column;
					None
				} else {
					Some(checked)
				}
			} else {
				Some(checked)
			}
		} else {
			None
		};
		result
	}

	fn parse_leaf(&mut self, mut span: Span<'a>) -> LeafState<'a> {
		lazy_static! {
			static ref RE_BREAK: Regex = Regex::new(r"^\s*([-_*]\s*){3,}\s*$").unwrap();
			static ref RE_ATX_HEADER: Regex =
				Regex::new(r"^(?P<s>\s*(?P<h>[#]{1,6}))(\s.*?)??(?P<e>(\s#+)?\s*)$").unwrap();
			static ref RE_CODE_FENCE: Regex = Regex::new(
				r"(?x)
				^\s*
				(
					### Delimiter: ~~~ ###
					(?P<d0>~{3,})            # Main delimiter
					(\s*(?P<w0>\w+)(\s|$))?  # Optional language
					(?P<i0>.*)               # Additional info
					|
					### Delimiter: ``` ###
					(?P<d1>`{3,})            # Main delimiter
					(\s*(?P<w1>\w+)(\s|$))?  # Optional language
					(?P<i1>[^`]*)            # Additional info
				)$"
			)
			.unwrap();
		}

		let text = span.text();
		let (indent, _) = common::indent_width(text, span.column);
		if indent >= 4 {
			// ===================
			// Indented code block
			// ===================
			span.indent += 4;
			let code_block = Leaf::IndentedCode { code: span };
			LeafState::Open(code_block)
		} else if RE_BREAK.is_match(text) {
			// ===================
			// Semantic break
			// ===================
			LeafState::ClosedAndConsumed(Leaf::Break)
		} else if let Some(caps) = RE_ATX_HEADER.captures(text) {
			// ===================
			// ATX Heading
			// ===================
			let lvl = caps.name("h").unwrap().as_str().len() as u8;
			let sta = span.offset_sta + caps.name("s").unwrap().end();
			let end = span.offset_sta + caps.name("e").unwrap().start();
			span.offset_sta = sta;
			span.offset_end = end;
			span.indent = 0;
			span.column = common::text_column(&text[..sta], span.column);
			let leaf = Leaf::Header {
				level: lvl,
				text:  span,
			};
			LeafState::ClosedAndConsumed(leaf)
		} else if let Some(caps) = RE_CODE_FENCE.captures(text) {
			// ===================
			// Fenced code block
			// ===================
			let fence = caps.name("d0").unwrap_or_else(|| caps.name("d1").unwrap()).as_str();
			let lang = caps.name("l0");
			let lang = if let Some(x) = lang { Some(x) } else { caps.name("l1") };
			let lang = if let Some(x) = lang { x.as_str() } else { "" };
			let lang = if lang.len() > 0 { Some(lang) } else { None };
			let info = caps.name("i0");
			let info = if let Some(x) = info { Some(x) } else { caps.name("i1") };
			let info = if let Some(x) = info { x.as_str().trim() } else { "" };
			let info = if info.len() > 0 { Some(info) } else { None };
			span.indent = indent;
			LeafState::Open(Leaf::FencedCode {
				fence,
				lang,
				info,
				code: span,
			})
		} else if let Some(end) = Self::match_html_start(text, false) {
			// ===================
			// HTML block
			// ===================
			LeafState::Open(Leaf::HTML {
				end:  if end.len() == 0 { None } else { Some(end) },
				code: span,
			})
		} else if let Some(row) = parse_table_row(text, true) {
			// ===================
			// HTML block
			// ===================
			let table = match row {
				Row::Delimiter(count) => Leaf::Table {
					span: span,
					head: None,
					body: Vec::new(),
					cols: Some(count),
				},
				Row::Content(row) => Leaf::Table {
					span: span,
					head: Some(row),
					body: Vec::new(),
					cols: None,
				},
			};
			LeafState::Open(table)
		} else {
			LeafState::Open(Leaf::Paragraph { text: span })
		}
	}

	fn append_leaf(&mut self, mut leaf: Leaf<'a>, line_start: usize, line_end: usize, column: usize) -> LeafState<'a> {
		lazy_static! {
			static ref RE_SETEXT_HEADER: Regex = Regex::new(r"^[ ]{0,3}([-]{3,}|[=]{3,})\s*$").unwrap();
		}

		let line = &self.buffer[line_start..line_end];
		let line_trim = line.trim();
		let empty = line_trim.len() == 0;
		let (indent, _) = common::indent_width(line, column);
		match leaf {
			Leaf::Paragraph { mut text } => {
				if empty {
					LeafState::Closed(Leaf::Paragraph { text })
				} else if RE_SETEXT_HEADER.is_match(line) {
					let level = if line.trim().chars().next().unwrap() == '=' {
						1
					} else {
						2
					};
					let header = Leaf::Header { level, text };
					LeafState::ClosedAndConsumed(header)
				} else {
					// An HTML tag block can close a paragraph.
					let html = if indent <= 3 {
						Self::match_html_start(line, true)
					} else {
						None
					};
					if let Some(_) = html {
						LeafState::Closed(Leaf::Paragraph { text })
					} else {
						text.offset_end = line_end;
						LeafState::Open(Leaf::Paragraph { text })
					}
				}
			}
			Leaf::IndentedCode { ref mut code } => {
				if indent < 4 && !empty {
					LeafState::Closed(leaf)
				} else {
					if indent >= 4 {
						code.offset_end = line_end;
					}
					LeafState::Open(leaf)
				}
			}
			Leaf::FencedCode {
				fence,
				mut code,
				lang,
				info,
			} => {
				if indent < 4 {
					let delim = fence.chars().next().unwrap();
					let is_close = line_trim.starts_with(fence);
					let is_close = is_close && line_trim.chars().all(|ch| ch == delim);
					if is_close {
						code.offset_end = line_start;
						LeafState::ClosedAndConsumed(Leaf::FencedCode {
							fence,
							code,
							lang,
							info,
						})
					} else {
						code.offset_end = line_end;
						LeafState::Open(Leaf::FencedCode {
							fence,
							code,
							lang,
							info,
						})
					}
				} else {
					code.offset_end = line_end;
					LeafState::Open(Leaf::FencedCode {
						fence,
						code,
						lang,
						info,
					})
				}
			}
			Leaf::HTML { end, mut code } => {
				if let Some(end) = end {
					code.offset_end = line_end;
					let html = Leaf::HTML { end: Some(end), code };
					if line_trim.contains(end) {
						LeafState::ClosedAndConsumed(html)
					} else {
						LeafState::Open(html)
					}
				} else {
					let html = Leaf::HTML { end: None, code };
					if empty {
						LeafState::Closed(html)
					} else {
						LeafState::Open(html)
					}
				}
			}

			Leaf::Table {
				mut span,
				head,
				mut body,
				mut cols,
			} => {
				let has_separator = cols.is_some();
				if let Some(row) = parse_table_row(line_trim, !has_separator) {
					let mut is_valid = true;
					match row {
						Row::Delimiter(count) => {
							if count == head.as_ref().unwrap().len() {
								cols = Some(count);
							} else {
								// delimiter line must match the number of
								// cells in the header
								is_valid = false;
							}
						}
						Row::Content(row) => {
							if has_separator {
								body.push(row);
							} else {
								// second line of the table must be a separator
								is_valid = false;
							}
						}
					}

					if is_valid {
						span.offset_end = line_end;
						LeafState::Open(Leaf::Table { span, head, body, cols })
					} else {
						if empty {
							LeafState::Closed(Leaf::Paragraph { text: span })
						} else {
							span.offset_end = line_end;
							LeafState::Open(Leaf::Paragraph { text: span })
						}
					}
				} else {
					if has_separator && (head.is_some() || body.len() > 0) {
						LeafState::Closed(Leaf::Table { span, head, body, cols })
					} else if empty {
						LeafState::Closed(Leaf::Paragraph { text: span })
					} else {
						span.offset_end = line_end;
						LeafState::Open(Leaf::Paragraph { text: span })
					}
				}
			}

			// Those are closed as soon as they are parsed, so they will never
			// be appended to:
			Leaf::Break | Leaf::Header { .. } => unreachable!(),

			// Those are parsed when closing, so they would not occur either.
			Leaf::LinkReference { .. } => unreachable!(),
		}
	}

	fn close_leaf(&mut self, leaf: Leaf<'a>) -> Leaf<'a> {
		if let Leaf::Paragraph { text } = leaf {
			super::parse_link_ref(text)
		} else {
			leaf
		}
	}

	/// Check if the line contains
	fn match_html_start(line: &str, inline: bool) -> Option<&'static str> {
		lazy_static! {
			static ref TAGS: Vec<&'static str> = vec![
				"address",
				"article",
				"aside",
				"base",
				"basefont",
				"blockquote",
				"body",
				"caption",
				"center",
				"col",
				"colgroup",
				"dd",
				"details",
				"dialog",
				"dir",
				"div",
				"dl",
				"dt",
				"fieldset",
				"figcaption",
				"figure",
				"footer",
				"form",
				"frame",
				"frameset",
				"h1",
				"h2",
				"h3",
				"h4",
				"h5",
				"h6",
				"head",
				"header",
				"hr",
				"html",
				"iframe",
				"legend",
				"li",
				"link",
				"main",
				"menu",
				"menuitem",
				"nav",
				"noframes",
				"ol",
				"optgroup",
				"option",
				"p",
				"param",
				"section",
				"source",
				"summary",
				"table",
				"tbody",
				"td",
				"tfoot",
				"th",
				"thead",
				"title",
				"tr",
				"track",
				"ul",
			];
		}

		fn is_tag_end(text: &str, closed: bool) -> bool {
			text.trim().len() == 0
				|| text.starts_with(|ch| ch == ' ' || ch == '>')
				|| (closed && text.starts_with("/>"))
		}

		let text_trim = line.trim_start();
		if text_trim.starts_with('<') {
			if text_trim.starts_with("<!--") {
				return Some("-->");
			}
			if text_trim.starts_with("<?") {
				return Some("?>");
			}
			if text_trim.starts_with("<![CDATA[") {
				return Some("]]>");
			}

			if text_trim.len() > 2 && text_trim.starts_with("<!") {
				let ch = text_trim.as_bytes()[2] as char;
				if ch >= 'A' && ch <= 'Z' {
					return Some(">");
				}
			}

			let lc = text_trim.to_lowercase();

			let m = lc.trim_start_matches("<script");
			if m.len() < lc.len() && is_tag_end(m, false) {
				return Some("</script>");
			}
			let m = lc.trim_start_matches("<pre");
			if m.len() < lc.len() && is_tag_end(m, false) {
				return Some("</pre>");
			}
			let m = lc.trim_start_matches("<style");
			if m.len() < lc.len() && is_tag_end(m, false) {
				return Some("</style>");
			}

			let m = lc.trim_start_matches("<");
			if m.len() < lc.len() {
				let m = m.trim_start_matches("/");
				for s in TAGS.iter() {
					let n = m.trim_start_matches(s);
					if n.len() < lc.len() && is_tag_end(n, true) {
						return Some("");
					}
				}
			}

			if !inline {
				lazy_static! {
					static ref RE_OPEN_TAG: Regex = Regex::new(
						r#"(?ix)
							^<
							[a-z][-a-z0-9]*              # Tag name

							# Attributes
							(
								\s+[_:a-z][-a-z0-9._:]*  # Attribute name

								# Attribute value
								(
									\s*=\s*
									(
										[^"'=<>`]+       # Unquoted value
										|
										'[^']*'          # Single quoted value
										|
										"[^"]*"          # Double quoted value
									)
								)?
							)*

							\s* /?>
						"#
					)
					.unwrap();
				}

				if RE_OPEN_TAG.is_match(text_trim) {
					return Some("");
				}
			}
		}
		None
	}

	//
	// Helper methods for text parsing
	//

	/// Return the buffer text at the current offset.
	#[inline(always)]
	fn text(&self) -> &'a str {
		&self.buffer[self.offset..]
	}

	/// Return the next charater at the current offset. Panics at the end of
	/// the input.
	#[inline(always)]
	fn next_char(&self) -> char {
		self.text().chars().next().unwrap()
	}

	/// Skip the next char, only if it is equal to the given one.
	#[inline(always)]
	fn skip_if(&mut self, chr: char) -> bool {
		if self.text().starts_with(chr) {
			self.skip_chars(1);
			true
		} else {
			false
		}
	}

	/// Skip entire chars from the input.
	#[inline(always)]
	fn skip_chars(&mut self, n: usize) {
		let text_len = self.buffer.len() - self.offset;
		let skip_len = self
			.text()
			.char_indices()
			.skip(n)
			.map(|x| x.0)
			.next()
			.unwrap_or(text_len);
		self.skip(skip_len);
	}

	/// Skip [offset] by the given number of bytes, updating [column].
	fn skip(&mut self, len: usize) {
		for ch in (&self.buffer[self.offset..self.offset + len]).chars() {
			match ch {
				'\r' | '\n' => self.column = 0,
				'\t' => self.column = common::tab(self.column),
				_ => self.column += 1,
			}
		}
		self.offset += len;
	}

	/// `true` if the current offset is at the end of the input.
	#[inline]
	fn at_end(&mut self) -> bool {
		self.offset >= self.buffer.len()
	}

	/// Returns the text for the current line, excluding the EOL marker.
	fn cur_line(&mut self) -> &'a str {
		let (next_line, eol_length) = self.line_end();
		&self.buffer[self.offset..next_line - eol_length]
	}

	/// Find the position of the next line and the size of the EOL sequence.
	///
	/// Returns `(next_line, eol_length)` where
	/// - `next_line` is the byte offset for the start of the next line;
	/// - `eol_length` is the size in bytes of the EOL sequence.
	fn line_end(&mut self) -> (usize, usize) {
		if let Some((next_line, eol_length)) = self.next_line {
			if next_line > self.offset {
				return (next_line, eol_length);
			}
		}

		let mut iter = (&self.buffer[self.offset..]).char_indices();
		let mut eol_pos = None;
		let mut eol_len = 0;
		while let Some((pos, chr)) = iter.next() {
			if chr == '\r' || chr == '\n' {
				eol_pos = Some(pos + self.offset);
				eol_len = 1;
				if chr == '\r' {
					if let Some((_, '\n')) = iter.next() {
						eol_len = 2;
					}
				}
				break;
			}
		}

		let eol_pos = match eol_pos {
			Some(pos) => pos,
			None => self.buffer.len(),
		};

		let out = (eol_pos + eol_len, eol_len);
		self.next_line = Some(out);
		out
	}
}

impl<'a> Iterator for BlockIterator<'a> {
	type Item = BlockEvent<'a>;

	fn next(&mut self) -> Option<Self::Item> {
		self.get_next()
	}
}

//
// TESTS
//

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_markdown_simple() {
		// Simple paragraphs
		test(
			r"
			Paragraph 1

			Paragraph 2

			3.1
			3.2
			",
			r"
			<p>Paragraph 1</p>
			<p>Paragraph 2</p>
			<p>3.1
			3.2</p>
			",
		);
	}

	#[test]
	fn test_markdown_breaks() {
		// Thematic breaks
		test(
			r"
				***

				---
				___

				P1

				---
				***
				___
				P2

				+++
				--
				**
				__

				 ***
				  * * *
				   *  *  *
			",
			r"
				<hr/>
				<hr/>
				<hr/>
				<p>P1</p>
				<hr/>
				<hr/>
				<hr/>
				<p>P2</p>
				<p>+++
				--
				**
				__</p>
				<hr/>
				<hr/>
				<hr/>
			",
		);
	}

	#[test]
	fn test_markdown_atx_headings() {
		test(
			r"
				# H 1
				## H 2
				### H 3
				#### H 4
				##### H 5
				###### H 6

				P1
				# H1 # ##############
				## H2##
				### H3 # # #
				P2
				####### H7
			",
			r"
				<h1>H 1</h1>
				<h2>H 2</h2>
				<h3>H 3</h3>
				<h4>H 4</h4>
				<h5>H 5</h5>
				<h6>H 6</h6>
				<p>P1</p>
				<h1>H1 #</h1>
				<h2>H2##</h2>
				<h3>H3 # #</h3>
				<p>P2
				####### H7</p>
			",
		)
	}

	#[test]
	fn test_markdown_setext_headings() {
		test(
			r"
				Title 1
				=======

				Title 2
				-------

				Multi-line
				Title 2
				---

				L1
				L2
				==
				===
				L3
				--
				---
			",
			r"
				<h1>Title 1</h1>
				<h2>Title 2</h2>
				<h2>Multi-line
				   Title 2</h2>
				<h1>L1
				L2
				==</h1>
				<h2>L3
				--</h2>
			",
		)
	}

	fn test(input: &str, expected: &str) {
		let input = common::text(input);
		let expected = common::text(expected);

		let items: Vec<_> = parse_blocks(&input).map(|x| format!("{:?}", x)).collect();
		let result = items.join("\n");

		assert_eq!(result, expected);
	}
}
