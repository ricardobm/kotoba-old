use regex::Regex;
use std::collections::LinkedList;

/// Markdown elements.
///
/// These elements are generated by the parser in order, as they are encountered
/// in the document.
#[derive(Clone, Debug)]
pub enum Element<'a> {
	ParagraphStart,
	ParagraphEnd,
	Break,
	Text(&'a str),
}

/// Parse the input string as markdown, returning a markdown iterator.
pub fn parse_markdown<'a>(input: &'a str) -> MarkdownIterator<'a> {
	MarkdownIterator::new(input)
}

/// Mantains a parser state.
#[derive(Clone, Debug, PartialEq, Eq)]
enum State {
	/// Initial state, outside of any block.
	Start,
	/// At the start of an inline block.
	Inline,
	/// At the end of an inline block.
	InlineEnd,
}

pub struct MarkdownIterator<'a> {
	cursor: ParserCursor<'a>,
	list:   LinkedList<Element<'a>>,
}

impl<'a> MarkdownIterator<'a> {
	fn new(input: &'a str) -> MarkdownIterator<'a> {
		MarkdownIterator {
			cursor: ParserCursor {
				buffer: input,
				..Default::default()
			},
			list:   Default::default(),
		}
	}

	fn get_next(&mut self) -> Option<Element<'a>> {
		lazy_static! {
			static ref RE_BREAK: Regex = Regex::new(r"^[ ]{0,3}([-_*]\s*){3,}\s*$").unwrap();
		}

		if self.cursor.at_end() {
			if let Some(elem) = self.list.pop_back() {
				Some(elem)
			} else {
				None
			}
		} else {
			let (new_state, elem) = match &self.cursor.state {
				State::Start => {
					if let Some(_) = self.cursor.cur_block(false) {
						if RE_BREAK.is_match(self.cursor.cur_line()) {
							self.cursor.skip_line();
							(State::Start, Some(Element::Break))
						} else {
							self.list.push_back(Element::ParagraphEnd);
							(State::Inline, Some(Element::ParagraphStart))
						}
					} else {
						(State::Start, None)
					}
				}
				State::Inline => {
					let range = self.cursor.cur_block(true).unwrap();
					let text = &self.cursor.buffer[range];
					(State::InlineEnd, Some(Element::Text(text.trim())))
				}
				State::InlineEnd => (State::Start, self.list.pop_back()),
			};
			self.cursor.state = new_state;
			elem
		}
	}
}

impl<'a> Iterator for MarkdownIterator<'a> {
	type Item = Element<'a>;

	fn next(&mut self) -> Option<Self::Item> {
		self.get_next()
	}
}

type Range = std::ops::Range<usize>;

/// Mantains information about the current position and state in the parser
/// buffer.
#[derive(Clone)]
struct ParserCursor<'a> {
	buffer: &'a str,
	offset: usize,
	state:  State,

	pos_eol: Option<usize>,

	range_block: Option<Range>,
}

impl<'a> Default for ParserCursor<'a> {
	fn default() -> ParserCursor<'a> {
		ParserCursor {
			buffer: "",
			offset: 0,
			state:  State::Start,

			pos_eol: Default::default(),

			range_block: Default::default(),
		}
	}
}

impl<'a> ParserCursor<'a> {
	/// Move `offset` to a new position.
	///
	/// This is the only function that should be allowed to change `offset`.
	#[inline]
	fn move_to(&mut self, pos: usize) {
		self.offset = pos;
		self.pos_eol = None;
		self.range_block = None;
	}

	fn cur_block(&mut self, consume: bool) -> Option<Range> {
		let out = if let Some(range) = &self.range_block {
			Some(range.clone())
		} else {
			self.skip_blank();

			let my_indent = self.cur_indent();
			self.range_block = if self.at_end() {
				None
			} else {
				let mut aux = self.clone();
				aux.skip_line();
				while aux.cur_indent() == my_indent && aux.cur_line().trim().len() != 0 {
					aux.skip_line();
				}
				Some(Range {
					start: self.offset,
					end:   aux.offset,
				})
			};
			self.range_block.clone()
		};
		if consume {
			if let Some(Range { end, .. }) = self.range_block {
				self.move_to(end);
			}
		}
		out
	}

	#[inline]
	fn at_end(&mut self) -> bool {
		self.offset >= self.buffer.len()
	}

	#[inline]
	fn cur_line(&mut self) -> &str {
		&self.buffer[self.offset..self.next_line()]
	}

	fn cur_indent(&mut self) -> usize {
		indent_width(self.cur_line(), 4)
	}

	/// Skip blank lines in the input.
	fn skip_blank(&mut self) {
		while !self.at_end() && self.cur_line().trim().len() == 0 {
			self.skip_line();
		}
	}

	/// Skip to the next line.
	fn skip_line(&mut self) {
		let next_offset = self.next_line();
		self.move_to(next_offset);
	}

	/// Offset for the next line.
	fn next_line(&mut self) -> usize {
		if let Some(pos) = self.pos_eol {
			pos
		} else {
			// find the next `\n` or `\r` from the offset position
			let text = &self.buffer[self.offset..];
			let mut iter = text.char_indices();
			while let Some((_, ch)) = iter.next() {
				if ch == '\r' || ch == '\n' {
					// we want the offset of the character after the line break
					let mut next = iter.next();
					if ch == '\r' {
						if let Some((_, '\n')) = next {
							next = iter.next();
						}
					}
					let eol_offset = next.unwrap_or((text.len(), ' ')).0;
					self.pos_eol = Some(self.offset + eol_offset);
					break;
				}
			}

			match self.pos_eol {
				Some(pos) => pos,
				None => {
					// we found the end of input before a line break
					self.pos_eol = Some(self.buffer.len());
					self.buffer.len()
				}
			}
		}
	}
}

fn indent_width(s: &str, tab_width: usize) -> usize {
	let mut width = 0;
	for chr in s.chars() {
		if chr == '\t' {
			width += tab_width - (width % tab_width);
		} else if chr.is_whitespace() {
			width += 1;
		} else {
			break;
		}
	}
	width
}

#[cfg(test)]
mod tests {
	use super::*;

	#[test]
	fn test_markdown_simple() {
		// Simple paragraphs
		test(
			r"
			Paragraph 1

			Paragraph 2

			3.1
			3.2
			",
			vec!["<p>Paragraph 1</p>", "<p>Paragraph 2</p>", "<p>3.1\n3.2</p>"],
		);
	}

	#[test]
	fn test_markdown_breaks() {
		// Thematic breaks
		test(
			r"
			***

			---
			___

			P1
			   ---
			   ***
			   ___
			P2

			+++
			--
			**
			__

			 ***
			  * * *
			   *  *  *
			",
			vec![
				"<hr/><hr/><hr/>",
				"<p>P1</p>",
				"<hr/><hr/><hr/>",
				"<p>P2</p>",
				"<p>+++\n--\n**\n__</p>",
				"<hr/><hr/><hr/>",
			],
		);
	}

	fn test(input: &str, expected: Vec<&'static str>) {
		lazy_static! {
			static ref RE_INDENT: Regex = Regex::new(r"^\s*").unwrap();
		}

		let mut base_indent = "";
		let mut input_text = String::new();
		let mut has_indent = false;
		for (i, line) in input.trim().lines().enumerate() {
			if !has_indent && i > 0 && line.trim().len() > 0 {
				base_indent = RE_INDENT.find(line).unwrap().as_str();
				has_indent = true;
			}

			let line = if line.starts_with(base_indent) {
				&line[base_indent.len()..]
			} else {
				line
			};
			if i > 0 {
				input_text.push('\n');
			}
			input_text.push_str(line);
		}

		let result = print_md(parse_markdown(input_text.as_str()));
		assert_eq!(result, expected.join(""));
	}

	fn print_md<'a>(input: MarkdownIterator<'a>) -> String {
		let mut output = String::new();
		for it in input {
			match it {
				Element::ParagraphStart => {
					output += "<p>";
				}
				Element::ParagraphEnd => {
					output += "</p>";
				}
				Element::Break => {
					output += "<hr/>";
				}
				Element::Text(text) => {
					output += text;
				}
			}
		}
		output
	}
}
